#!/usr/bin/env python2
## -*- coding: utf-8 -*-

# Assumptions: we've already used taint analysis to determine there's a 
#              user-controllable indirect call site, now we're using 
#              symbex to figure out how to control it

import sys
import triton
import pintool

taintedCallsite = 0x400bef  # Found in a previous DTA pass
target          = 0x400b3b  # Target to redirect callsite to

Triton = pintool.getTritonContext()

def symbolize_inputs(tid):
    rdi = pintool.getCurrentRegisterValue(Triton.registers.rdi) # argc
    rsi = pintool.getCurrentRegisterValue(Triton.registers.rsi) # argv

    # for each string in argv
    while rdi > 1:
        addr = pintool.getCurrentMemoryValue(rsi + ((rdi-1)*triton.CPUSIZE.QWORD), triton.CPUSIZE.QWORD)
        # symbolize the current argument string (including the terminating NULL)
        c = None
        s = ''
        while c != 0:
            c = pintool.getCurrentMemoryValue(addr)
            s += chr(c)
            Triton.setConcreteMemoryValue(addr, c)
            Triton.convertMemoryToSymbolicVariable(triton.MemoryAccess(addr, triton.CPUSIZE.BYTE)).setComment('argv[%d][%d]' % (rdi-1, len(s)-1))
            addr += 1
        rdi -= 1
        print 'Symbolized argument %d: %s' % (rdi, s)

def exploit_icall(insn, op):
    regId   = Triton.getSymbolicRegisterId(op)
    regExpr = Triton.unrollAst(Triton.getAstFromId(regId))
    ast = Triton.getAstContext()

    exploitExpr = ast.equal(regExpr, ast.bv(target, triton.CPUSIZE.QWORD_BIT))
    for k, v in Triton.getSymbolicVariables().iteritems():
        if 'argv' in v.getComment():
            # Argument characters must be printable
            argExpr = Triton.getAstFromId(k)
            argExpr = ast.land([
                          ast.bvuge(argExpr, ast.bv(32,  triton.CPUSIZE.BYTE_BIT)),
                          ast.bvule(argExpr, ast.bv(126, triton.CPUSIZE.BYTE_BIT))
                      ])
            exploitExpr = ast.land([exploitExpr, argExpr])

    print 'Getting model for %s -> 0x%x' % (insn, target)
    model = Triton.getModel(exploitExpr)
    for k, v in model.iteritems():
        print '%s (%s)' % (v, Triton.getSymbolicVariableFromId(k).getComment())

def hook_icall(insn):
    if insn.isControlFlow() and insn.getAddress() == taintedCallsite:
        for op in insn.getOperands():
            if op.getType() == triton.OPERAND.REG:
                print 'Found tainted indirect call site \'%s\'' % (insn)
                exploit_icall(insn, op)

def main():
    Triton.setArchitecture(triton.ARCH.X86_64)
    Triton.enableMode(triton.MODE.ALIGNED_MEMORY, True)

    pintool.startAnalysisFromSymbol('main')

    pintool.insertCall(symbolize_inputs, pintool.INSERT_POINT.ROUTINE_ENTRY, 'main')
    pintool.insertCall(hook_icall, pintool.INSERT_POINT.BEFORE)

    pintool.runProgram()

if __name__ == '__main__':
    main()

